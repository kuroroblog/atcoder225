################################
# <方針>
# 電車の連結状態を前部(front)と後部(back)に分ける。
# `1 x y`のクエリを実行する場合、
# クエリを処理する直前に、電車xの後部と連結している電車は存在しないと書かれているので、
# back[x] = yとなる。
# クエリを処理する直前に、電車yの前部と連結している電車は存在しないと書かれているので、
# front[y] = xとなる。
# それ以外の場合は電車通しが連結していないため、-1などの値を入れておく。

# `2 x y`のクエリを実行する場合、電車の連結を外すために
# back[x] = -1とする。
# front[y] = -1とする。

# `3 x`のクエリを実行する場合、
# front[x] != -1を繰り返し(一番前の電車番号を探す)、back[x] != -1の値を出力していく。(順に電車の番号を辿っていく。)
################################

# 標準入力を受け付ける。
N, Q = map(int, input().split())

front = []
back = []
for i in range(N + 1):
    front.append(-1)
    back.append(-1)

for _ in range(Q):
    q = list(map(int, input().split()))

    # 電車の連結状態を前部(front)と後部(back)に分ける。
    # `1 x y`のクエリを実行する場合、
    # クエリを処理する直前に、電車xの後部と連結している電車は存在しないと書かれているので、
    # back[x] = yとなる。
    # クエリを処理する直前に、電車yの前部と連結している電車は存在しないと書かれているので、
    # front[y] = xとなる。
    # それ以外の場合は電車通しが連結していないため、-1などの値を入れておく。
    if q[0] == 1:
        x = q[1]
        y = q[2]
        front[y] = x
        back[x] = y

    # `2 x y`のクエリを実行する場合、電車の連結を外すために
    # back[x] = -1とする。
    # front[y] = -1とする。
    if q[0] == 2:
        x = q[1]
        y = q[2]
        front[y] = -1
        back[x] = -1

    if q[0] == 3:
        x = q[1]

        # `3 x`のクエリを実行する場合、
        # front[x] != -1を繰り返し(一番前の電車番号を探す)、back[x] != -1の値を出力していく。(順に電車の番号を辿っていく。)
        ret = []
        while front[x] != -1:
            x = front[x]
        ret = [x]
        while back[x] != -1:
            ret.append(back[x])
            x = back[x]

        print(len(ret), *ret)

